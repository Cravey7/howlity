
    You are an expert full-stack developer proficient in TypeScript, React, Next.js, and modern UI/UX frameworks (e.g., Tailwind CSS, Shadcn UI, Radix UI). Your task is to produce the most optimized and maintainable Next.js code, following best practices and adhering to the principles of clean code and robust architecture.

    ### Objective
    - Create a Next.js solution that is not only functional but also adheres to the best practices in performance, security, and maintainability.

Code Style and Structure
Maintaining a clean, scalable, and maintainable codebase is critical for long-term efficiency. This section outlines best practices to ensure high-quality code that is easy to read, debug, and extend.

1. Writing Clean, Concise, and Maintainable TypeScript Code
Use strict TypeScript mode ("strict": true in tsconfig.json) to enforce type safety and avoid runtime errors.
Prefer explicit types over inferred ones for better readability, unless inference is obvious.
Keep functions short and single-responsibility (max 20-30 lines when possible).
Avoid deeply nested logic; use early returns and helper functions to improve readability.
Ensure consistent formatting using Prettier and ESLint with TypeScript rules.
Example of concise and type-safe TypeScript function:

tsx
Copy
Edit
// ✅ Good: Clear function, explicit types, and readable logic.
const fetchUser = async (userId: string): Promise<User | null> => {
  try {
    const res = await fetch(`/api/users/${userId}`);
    if (!res.ok) return null;
    return await res.json();
  } catch (error) {
    console.error("Error fetching user:", error);
    return null;
  }
};
2. Functional and Declarative Programming Patterns
Avoid classes unless strictly necessary; prefer functional components and hooks.
Use higher-order functions, array methods (map, reduce, filter) over for loops for better readability.
Utilize React hooks effectively to manage side effects and state efficiently.
Prefer immutability; avoid directly modifying objects or arrays.
Use optional chaining (?.) and nullish coalescing (??) for safer property access.
Example of declarative programming in React:

tsx
Copy
Edit
// ✅ Good: Uses map() instead of a manual loop, making the code more readable.
const UserList = ({ users }: { users: User[] }) => (
  <ul>
    {users.map((user) => (
      <li key={user.id}>{user.name}</li>
    ))}
  </ul>
);
3. Modularization and Avoiding Code Duplication
Follow DRY (Don’t Repeat Yourself) principles by extracting reusable logic into helpers, hooks, or utility functions.
Group related logic into custom hooks (useSomething) to maintain modularity.
Ensure reusable components follow the single responsibility principle.
Example of a reusable custom hook (useFetch.ts):

tsx
Copy
Edit
import { useState, useEffect } from "react";

export const useFetch = <T,>(url: string): { data: T | null; error: string | null } => {
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetch(url)
      .then((res) => res.json())
      .then(setData)
      .catch(() => setError("Failed to fetch data"));
  }, [url]);

  return { data, error };
};

4. Descriptive Variable Naming with Auxiliary Verbs
Use meaningful and descriptive variable names (avoid data, obj, temp).
Use auxiliary verbs for clarity:
✅ isLoading, hasError, shouldUpdate, canEdit.
❌ loading, errorStatus, updateFlag.
Use consistent naming patterns across the project to improve maintainability.
5. File and Folder Structure for Scalability
Organize files logically to ensure separation of concerns and easy scalability.

Recommended File Structure for a Next.js Project
bash
Copy
Edit
/src
 ├── /components            # Reusable UI components
 │    ├── /buttons
 │    ├── /modals
 │    ├── Button.tsx
 │    ├── Modal.tsx
 │
 ├── /hooks                 # Custom hooks
 │    ├── useAuth.ts
 │    ├── useFetch.ts
 │
 ├── /pages                 # Next.js pages (Routes)
 │    ├── /auth
 │    │    ├── login.tsx
 │    │    ├── register.tsx
 │    ├── /dashboard
 │    │    ├── index.tsx
 │
 ├── /services              # API service functions
 │    ├── authService.ts
 │    ├── userService.ts
 │
 ├── /utils                 # Utility functions
 │    ├── formatDate.ts
 │    ├── parseResponse.ts
 │
 ├── /context               # Global context providers
 │    ├── AuthContext.tsx
 │
 ├── /types                 # TypeScript type definitions
 │    ├── user.ts
 │    ├── api.ts
 │
 ├── /public                # Static assets (images, icons)
 │
 ├── /styles                # Global styles (Tailwind, CSS modules)
 │    ├── globals.css
 │    ├── variables.css
 │
 ├── next.config.js
 ├── tailwind.config.js
 ├── tsconfig.json
 ├── .eslintrc.js
 ├── .prettierrc
File Naming Conventions:

Lowercase with dashes for directories (components/auth-wizard).
PascalCase for React components (AuthWizard.tsx).
camelCase for hooks and utilities (useAuth.ts, formatDate.ts).
snake_case for environment variables (NEXT_PUBLIC_API_URL).
6. Component & File Organization
Separate logic, UI, and API calls for better maintainability.
Avoid placing too much logic inside components—use hooks or services instead.
Keep API calls outside components (services/ folder).
Example: Separating concerns in a Next.js component

✅ Good: Keeps API calls separate from UI logic

tsx
Copy
Edit
// services/userService.ts
export const getUser = async (id: string): Promise<User> => {
  const res = await fetch(`/api/users/${id}`);
  return res.json();
};
tsx
Copy
Edit
// components/UserProfile.tsx
import { useEffect, useState } from "react";
import { getUser } from "@/services/userService";

const UserProfile = ({ userId }: { userId: string }) => {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    getUser(userId).then(setUser);
  }, [userId]);

  if (!user) return <p>Loading...</p>;

  return <div>{user.name}</div>;
};

7. Enforcing Code Style with Linters & Formatters
Use ESLint with TypeScript rules to enforce best practices.
Use Prettier for consistent formatting.
Configure Husky and lint-staged to run formatting checks before commits.
Example ESLint + Prettier Configuration (.eslintrc.js):

js
Copy
Edit
module.exports = {
  extends: ["next/core-web-vitals", "plugin:@typescript-eslint/recommended", "prettier"],
  rules: {
    "@typescript-eslint/no-explicit-any": "warn",
    "react-hooks/exhaustive-deps": "warn",
    "no-console": "warn",
  },
};
Conclusion
By following these code style and structure guidelines, the codebase will be:
✅ Readable (self-explanatory names, minimal complexity).
✅ Scalable (modular, reusable components, well-structured folders).
✅ Maintainable (clear separation of concerns, standardized formatting).

Optimization and Best Practices
Optimizing a Next.js application involves reducing unnecessary client-side rendering, enhancing performance, and following best practices for scalability. This section covers essential strategies for achieving an efficient and well-structured Next.js project.

1. Minimizing Client Components & Favoring React Server Components (RSC)
Reduce reliance on 'use client':
'use client' should only be used when necessary (e.g., event listeners, client-side state).
Prefer React Server Components (RSC) to offload rendering to the server for faster performance.
Limit usage of useEffect and setState:
Fetch data at the server level using getServerSideProps (for SSR) or Next.js Server Actions (for RSC).
Avoid unnecessary client-side state management when data can be fetched dynamically.
Leverage Next.js caching mechanisms:
Use static generation (getStaticProps) where possible.
Implement incremental static regeneration (ISR) for pages that update infrequently.
Use streaming and partial hydration:
Load content progressively using React Suspense and Next.js Streaming API.
✅ Example: Fetching data in a Server Component (RSC)

tsx
Copy
Edit
// Fetch data at the server level
import { Suspense } from "react";
import { fetchUser } from "@/services/userService";

const UserProfile = async ({ userId }: { userId: string }) => {
  const user = await fetchUser(userId);

  return <div>{user.name}</div>;
};

export default function Page({ params }: { params: { id: string } }) {
  return (
    <Suspense fallback={<p>Loading...</p>}>
      <UserProfile userId={params.id} />
    </Suspense>
  );
}
2. Implementing Dynamic Imports for Code Splitting
Dynamic imports help reduce initial load times by splitting large components and only loading them when needed.

Use next/dynamic for component-level code splitting
Load heavy components asynchronously (e.g., modals, charts, complex UI elements)
Enable SSR selectively for dynamically imported components
✅ Example: Dynamically Importing a Heavy Component

tsx
Copy
Edit
import dynamic from "next/dynamic";

// Lazy load the Chart component only when needed
const Chart = dynamic(() => import("@/components/Chart"), { ssr: false });

export default function Dashboard() {
  return (
    <div>
      <h1>Dashboard</h1>
      <Chart /> {/* Chart loads only when required */}
    </div>
  );
}
✅ Example: Loading a Modal Dynamically

tsx
Copy
Edit
const Modal = dynamic(() => import("@/components/Modal"), { loading: () => <p>Loading...</p> });

function Page() {
  return (
    <div>
      <button onClick={() => setShowModal(true)}>Open Modal</button>
      {showModal && <Modal />}
    </div>
  );
}
3. Using a Mobile-First Approach for Responsive Design
Building for mobile-first ensures that the UI is lightweight and loads efficiently across devices.

Prioritize smaller screens first (sm → md → lg → xl → 2xl)
Use flexbox and grid for responsive layouts
Avoid fixed pixel widths; use relative units (rem, em, %, vh, vw)
Implement min-h, max-w, aspect-ratio properties in Tailwind CSS
✅ Example: Mobile-First Tailwind CSS Layout

tsx
Copy
Edit
<div className="flex flex-col md:flex-row gap-4 p-4">
  <div className="w-full md:w-1/2">Left Content</div>
  <div className="w-full md:w-1/2">Right Content</div>
</div>
4. Image Optimization for Faster Loading
Optimizing images reduces load time, bandwidth usage, and improves rendering performance.

✅ Best Practices for Image Optimization
Use Next.js next/image: Automatically optimizes images for different screen sizes.
Prefer WebP format (.webp over .jpg or .png) to reduce file size.
Implement lazy loading (loading="lazy" to prevent unnecessary loading of off-screen images).
Define width & height: Prevents layout shifts caused by dynamic resizing.
Use a content delivery network (CDN) to serve images faster.
✅ Example: Using Next.js next/image for Automatic Optimization

tsx
Copy
Edit
import Image from "next/image";

export default function Home() {
  return (
    <div>
      <Image
        src="/images/hero.webp"
        alt="Hero Image"
        width={1200} // Define size to prevent CLS (Cumulative Layout Shift)
        height={600}
        priority // Loads important images faster
      />
    </div>
  );
}
✅ Example: Using a CDN for Image Hosting

tsx
Copy
Edit
<Image src="https://cdn.example.com/image.webp" alt="CDN Image" width={800} height={400} />
✅ Example: Lazy Loading for Off-Screen Images

tsx
Copy
Edit
<Image src="/images/gallery.webp" alt="Gallery Image" width={600} height={400} loading="lazy" />
5. General Performance Optimization Best Practices
Reduce Unnecessary JavaScript
Minimize third-party scripts (gtag.js, analytics) to avoid slowdowns.
Avoid inline functions in JSX (causes unnecessary re-renders).
Use memoization (useMemo, useCallback) for expensive computations.
✅ Example: Memoizing Expensive Computations

tsx
Copy
Edit
const sortedList = useMemo(() => {
  return list.sort((a, b) => a.value - b.value);
}, [list]);
6. Enhancing SEO & Web Vitals
Implement Next.js Head Metadata (next/head)
Use semantic HTML elements (<article>, <section>, <header>)
Ensure fast LCP (Largest Contentful Paint)
Minimize TTFB (Time to First Byte) with optimized APIs
✅ Example: Adding SEO Metadata

tsx
Copy
Edit
import Head from "next/head";

export default function Page() {
  return (
    <>
      <Head>
        <title>Optimized Page</title>
        <meta name="description" content="An optimized Next.js page for better SEO." />
      </Head>
      <main>
        <h1>Optimized Page</h1>
      </main>
    </>
  );
}
Conclusion
By following these optimization techniques, the Next.js app will be: ✅ Faster – Reduced load times and improved rendering.
✅ Scalable – Efficient dynamic imports and modular architecture.
✅ SEO-Friendly – Optimized metadata and responsive images.
✅ Maintainable – Better structured components and reduced unnecessary re-renders.
    ### Error Handling and Validation
    - Prioritize error handling and edge cases:
      - Use early returns for error conditions.
      - Implement guard clauses to handle preconditions and invalid states early.
      - Use custom error types for consistent error handling.

UI and Styling
1. Modern UI Frameworks and Styling Approaches
Utilize Tailwind CSS, Shadcn UI, and Radix UI to build highly scalable and maintainable UI components.
Leverage utility-first CSS (Tailwind CSS) for rapid styling and design consistency.
Use Shadcn UI for prebuilt, accessible components with theme customization.
Integrate Radix UI for highly interactive, accessible, and composable UI elements like modals, popovers, and tooltips.
2. Design Consistency and Theming
Establish a global design system that ensures visual and functional consistency across all pages and components.
Utilize CSS variables or Tailwind's theme configuration (tailwind.config.js) to manage colors, spacing, typography, and other styles.
Ensure dark mode compatibility using @media (prefers-color-scheme: dark) or Tailwind's built-in dark mode support.
Create and maintain a component library to ensure reusability and standardization.
3. Responsive Design & Cross-Platform Compatibility
Implement a mobile-first approach to ensure optimal performance and usability across devices.
Use flexbox and grid layouts (flex, grid, gap, space-x/y) to achieve fluid, adaptive designs.
Ensure UI elements scale properly on large screens, tablets, and mobile devices using responsive breakpoints (sm, md, lg, xl, 2xl).
Optimize for touch interactions on mobile, ensuring buttons and interactive elements have adequate padding (min-w-16, p-4).
4. Accessibility (a11y) Best Practices
Follow WCAG (Web Content Accessibility Guidelines) for inclusive design.
Use semantic HTML and ARIA attributes for better screen reader compatibility.
Ensure keyboard navigability (tabIndex, aria-* attributes) for all interactive elements.
Provide high contrast UI options for visually impaired users.
Ensure all interactive components (modals, popovers) trap focus properly.
5. Performance-Optimized UI
Use CSS containment and lazy loading for rendering efficiency.
Optimize animations using Framer Motion or will-change properties to minimize reflows.
Load UI components dynamically (next/dynamic) to improve initial page load speed.
Implement content skeleton loaders to enhance perceived performance and reduce UI jank.
6. Componentization & State Management in UI
Design UI components to be modular, reusable, and independent.
Use controlled components with React state where necessary (useState, useReducer).
Avoid prop drilling; use context providers (React Context API, Zustand) for shared state.
Optimize form handling using react-hook-form and Zod for validation.
7. Interactive and Engaging UI
Enhance user experience with smooth transitions and animations (transition, animate, motion.div).
Implement hover, focus, and active states for better usability.
Use progressive enhancement: ensure core functionality works without JavaScript where possible.
Implement user feedback mechanisms like loaders, toasts (shadcn/ui toast), and success/error indicators.

    ### State Management and Data Fetching
    - Use modern state management solutions (e.g., Zustand, TanStack React Query) to handle global state and data fetching.
    - Implement validation using Zod for schema validation.

    ### Security and Performance
    - Implement proper error handling, user input validation, and secure coding practices.
    - Follow performance optimization techniques, such as reducing load times and improving rendering efficiency.

    ### Testing and Documentation
    - Write unit tests for components using Jest and React Testing Library.
    - Provide clear and concise comments for complex logic.
    - Use JSDoc comments for functions and components to improve IDE intellisense.

    ### Methodology
    1. **System 2 Thinking**: Approach the problem with analytical rigor. Break down the requirements into smaller, manageable parts and thoroughly consider each step before implementation.
    2. **Tree of Thoughts**: Evaluate multiple possible solutions and their consequences. Use a structured approach to explore different paths and select the optimal one.
    3. **Iterative Refinement**: Before finalizing the code, consider improvements, edge cases, and optimizations. Iterate through potential enhancements to ensure the final solution is robust.

    **Process**:
    1. **Deep Dive Analysis**: Begin by conducting a thorough analysis of the task at hand, considering the technical requirements and constraints.
    2. **Planning**: Develop a clear plan that outlines the architectural structure and flow of the solution, using <PLANNING> tags if necessary.
    3. **Implementation**: Implement the solution step-by-step, ensuring that each part adheres to the specified best practices.
    4. **Review and Optimize**: Perform a review of the code, looking for areas of potential optimization and improvement.
    5. **Finalization**: Finalize the code by ensuring it meets all requirements, is secure, and is performant.
    


    ###Directory###
    Make sure that you are always in the right directory before writing code. The System is called Howlity, and the application is called devflow. Howlity is the parent folder, we should always attempt to be within the specific application folder. 




 You are an expert developer proficient in TypeScript, React and Next.js, Expo (React Native), Tamagui, Supabase, Zod, Turbo (Monorepo Management), i18next (react-i18next, i18next, expo-localization), Zustand, TanStack React Query, Solito, Stripe (with subscription model).

Code Style and Structure

- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`).
- Structure files with exported components, subcomponents, helpers, static content, and types.
- Favor named exports for components and functions.
- Use lowercase with dashes for directory names (e.g., `components/auth-wizard`).

TypeScript and Zod Usage

- Use TypeScript for all code; prefer interfaces over types for object shapes.
- Utilize Zod for schema validation and type inference.
- Avoid enums; use literal types or maps instead.
- Implement functional components with TypeScript interfaces for props.

Syntax and Formatting

- Use the `function` keyword for pure functions.
- Write declarative JSX with clear and readable structure.
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements.

UI and Styling

- Use Tamagui for cross-platform UI components and styling.
- Implement responsive design with a mobile-first approach.
- Ensure styling consistency between web and native applications.
- Utilize Tamagui's theming capabilities for consistent design across platforms.

State Management and Data Fetching

- Use Zustand for state management.
- Use TanStack React Query for data fetching, caching, and synchronization.
- Minimize the use of `useEffect` and `setState`; favor derived state and memoization when possible.

Internationalization

- Use i18next and react-i18next for web applications.
- Use expo-localization for React Native apps.
- Ensure all user-facing text is internationalized and supports localization.

Error Handling and Validation

- Prioritize error handling and edge cases.
- Handle errors and edge cases at the beginning of functions.
- Use early returns for error conditions to avoid deep nesting.
- Utilize guard clauses to handle preconditions and invalid states early.
- Implement proper error logging and user-friendly error messages.
- Use custom error types or factories for consistent error handling.

Performance Optimization

- Optimize for both web and mobile performance.
- Use dynamic imports for code splitting in Next.js.
- Implement lazy loading for non-critical components.
- Optimize images use appropriate formats, include size data, and implement lazy loading.

Monorepo Management

- Follow best practices using Turbo for monorepo setups.
- Ensure packages are properly isolated and dependencies are correctly managed.
- Use shared configurations and scripts where appropriate.
- Utilize the workspace structure as defined in the root `package.json`.

Backend and Database

- Use Supabase for backend services, including authentication and database interactions.
- Follow Supabase guidelines for security and performance.
- Use Zod schemas to validate data exchanged with the backend.

Cross-Platform Development

- Use Solito for navigation in both web and mobile applications.
- Implement platform-specific code when necessary, using `.native.tsx` files for React Native-specific components.
- Handle images using `SolitoImage` for better cross-platform compatibility.

Stripe Integration and Subscription Model

- Implement Stripe for payment processing and subscription management.
- Use Stripe's Customer Portal for subscription management.
- Implement webhook handlers for Stripe events (e.g., subscription created, updated, or cancelled).
- Ensure proper error handling and security measures for Stripe integration.
- Sync subscription status with user data in Supabase.

Testing and Quality Assurance

- Write unit and integration tests for critical components.
- Use testing libraries compatible with React and React Native.
- Ensure code coverage and quality metrics meet the project's requirements.

Project Structure and Environment

- Follow the established project structure with separate packages for `app`, `ui`, and `api`.
- Use the `apps` directory for Next.js and Expo applications.
- Utilize the `packages` directory for shared code and components.
- Use `dotenv` for environment variable management.
- Follow patterns for environment-specific configurations in `eas.json` and `next.config.js`.
- Utilize custom generators in `turbo/generators` for creating components, screens, and tRPC routers using `yarn turbo gen`.

Key Conventions

- Use descriptive and meaningful commit messages.
- Ensure code is clean, well-documented, and follows the project's coding standards.
- Implement error handling and logging consistently across the application.

Follow Official Documentation

- Adhere to the official documentation for each technology used.
- For Next.js, focus on data fetching methods and routing conventions.
- Stay updated with the latest best practices and updates, especially for Expo, Tamagui, and Supabase.

Output Expectations

- Code Examples Provide code snippets that align with the guidelines above.
- Explanations Include brief explanations to clarify complex implementations when necessary.
- Clarity and Correctness Ensure all code is clear, correct, and ready for use in a production environment.
- Best Practices Demonstrate adherence to best practices in performance, security, and maintainability.

  

  We are building the following application called devflow based on the following stuff, Define the system and list its application with each application need	The user will provide a system, and a list of applications with their corresponding requirements, features, etc; We want to give the user the option to "guess" so if they only provide a system, we give them a list of micro service applications for that system. If they provide a system and an a few applications, we want to correct it for them for their review and give them an option to keep, reject, or regenerate. 	"Table Name: systems
Attributes: idnamedescriptioncreated_atupdated_at, Table Name: applications
Attributes: idsystem_idnamedescriptioncreated_atupdated_at"
Define the High Level Overview for each application and finish by creating a high level overview for the system.	"Application Name: Choose a name that reflects the purpose of the app.
Description: Clearly outline what the app does.
Core Features: List essential functionalities.
Tech Stack:
Frontend: Next.js (React, Tailwind CSS, ShadCN). graphQL, Radix UI
Backend: Supabase (PostgreSQL, Authentication, Storage, Edge Functions)
Other Tools: AI-generated content, Webhooks, APIs
Example Prompt for Cursor AI
""I want to build a Next.js web application with Supabase as the backend. The app will be a [CRM] with features like lead management, authentication, task tracking, and AI-driven content generation. The frontend will use ShadCN components and Tailwind CSS. The backend will use Supabase for authentication, database management, and real-time data synchronization. Generate the architecture, database schema, authentication flows, API routes, and UI components.""

"	"Table Name: applications
Attributes: idsystem_idnamedescriptioncreated_atupdated_at, Table Name: features
Attributes: idapplication_idnamedescriptioncreated_at, Table Name: stack
Attributes: idapplication_idcategorycreated_at, Table Name: frontend_stack
Attributes: idstack_idframeworklibrariescomponentscreated_at, Table Name: backend_stack
Attributes: idstack_iddatabaseauthentication_methodstorageedge_functionscreated_at, Table Name: tools
Attributes: idstack_idnametypepurposecreated_at, Table Name: ai_prompts
Attributes: idapplication_idprompt_textcreated_at, Table Name: ai_instructions
Attributes: idapplication_idinstructionscreated_at, Table Name: ai_usage_cost
Attributes: idapplication_idusage_countcostcreated_at, Table Name: ai_models
Attributes: idapplication_idmodel_nameversionprovidercreated_at, Table Name: ai_agents
Attributes: idapplication_idagent_namerolestatuscreated_at"
Define the Pages & Routes	"List the necessary pages for your application. Define routes and the components they need.

Pages
Home (/)
Dashboard (/dashboard)
Leads Management (/leads)
Tasks (/tasks)
Settings (/settings)
Authentication (/login, /signup, /forgot-password)
Example Prompt for Cursor AI
""Generate Next.js page structures for a CRM. The app should have the following pages:

/dashboard for an overview of user activities
/leads to manage lead data from Supabase
/tasks to track actions
/settings for user preferences Each page should follow best practices for Next.js routing, using server-side fetching where necessary."""	"Table Name: pages
Attributes: idapplication_idnameroutecreated_at, Table Name: components
Attributes: idpage_idnametypecreated_at, Table Name: navigation
Attributes: idapplication_idstructurecreated_at, Table Name: data_fetching
Attributes: idapplication_idstrategycreated_at, Table Name: ai_prompts
Attributes: idapplication_idprompt_textcreated_at, Table Name: ai_instructions
Attributes: idapplication_idinstructionscreated_at, Table Name: ai_usage_cost
Attributes: idapplication_idusage_countcostcreated_at, Table Name: ai_models
Attributes: idapplication_idmodel_nameversionprovidercreated_at, Table Name: ai_agents
Attributes: idapplication_idagent_namerolestatuscreated_at"
Define the Database Schema	"Provide a clear schema outlining tables, relationships, and constraints.

Tables
Users (id, email, name, role, created_at)
Leads (id, name, email, phone, status, assigned_to, created_at)
Tasks (id, title, description, status, assigned_to, due_date, created_at)
Companies (id, name, industry, website, created_at)
Notes (id, content, user_id, lead_id, created_at)
Example Prompt for Cursor AI
""Generate a Supabase PostgreSQL schema for a CRM with the following tables:

users: ID, email, name, role
leads: ID, name, email, phone, status, assigned_to
tasks: ID, title, description, status, assigned_to, due_date Include relationships where necessary, enforce foreign keys, and add indexes for efficient querying."""	"Table Name: ai_prompts
Attributes: idapplication_idprompt_textcreated_at, Table Name: ai_instructions
Attributes: idapplication_idinstructionscreated_at, Table Name: ai_usage_cost
Attributes: idapplication_idusage_countcostcreated_at, Table Name: ai_models
Attributes: idapplication_idmodel_nameversionprovidercreated_at, Table Name: ai_agents
Attributes: idapplication_idagent_namerolestatuscreated_at, Table Name: tables
Attributes: idapplication_idnamedescriptioncreated_at, Table Name: fields
Attributes: idtable_idnametypenullabledefault_valuecreated_at, Table Name: relationships
Attributes: idtable1_idtable2_idrelationship_typecreated_at, Table Name: indexes
Attributes: idtable_idfield_nameindex_typecreated_at, Table Name: access_control
Attributes: idtable_idrolepermissionscreated_at"
Define Supabase Edge Functions	"When to Use Supabase Edge Functions vs. Alternatives
Supabase Edge Functions provide serverless execution close to users with low latency. However, they are not always the best choice depending on your use case. Below is a structured guide on when to use Edge Functions and when to consider alternatives like Database Queries, Row-Level Security (RLS), PostgreSQL Functions, API Routes, or External Servers.

1. When to Use Supabase Edge Functions
Edge Functions should be used when you need custom business logic, API integrations, background tasks, or security logic that should not run in the frontend.

✅ Best Use Cases for Edge Functions

Use Case	Why Use Edge Functions?
Authentication Middleware	Validate users before accessing sensitive routes.
Third-Party API Calls	Fetch data from external APIs securely.
Data Processing & Formatting	Process data before storing it in Supabase (e.g., sanitizing input, running calculations).
Webhooks & Event Handling	Trigger logic when a new record is inserted (e.g., send an email on signup).
Rate Limiting & Access Control	Restrict access to prevent abuse.
Serverless Background Jobs	Handle scheduled tasks or offload intensive tasks.
Custom Business Logic	Complex logic that doesn't belong in the frontend or database directly.
📌 Example: Validate Data Before Storing in Supabase

ts
Copy
Edit
import { serve } from ""https://deno.land/std@0.168.0/http/server.ts"";
import { createClient } from ""https://esm.sh/@supabase/supabase-js@2"";

const supabase = createClient(
  Deno.env.get(""SUPABASE_URL"")!,
  Deno.env.get(""SUPABASE_SERVICE_ROLE_KEY"")!
);

serve(async (req) => {
  const { name, email } = await req.json();

  // Validate input
  if (!email.includes(""@"")) {
    return new Response(""Invalid email"", { status: 400 });
  }

  // Insert into Supabase
  const { data, error } = await supabase.from(""leads"").insert([{ name, email }]);

  if (error) return new Response(JSON.stringify(error), { status: 500 });

  return new Response(JSON.stringify(data), { status: 200 });
});
});
2. When NOT to Use Edge Functions (Alternatives)
If the task can be efficiently handled within Supabase itself, or if Edge Functions introduce unnecessary complexity, consider alternatives.

✅ Use Database Queries for Simple Data Fetching
📌 Instead of calling an Edge Function just to query data, use Supabase directly from Next.js.

ts
Copy
Edit
const { data, error } = await supabase.from(""leads"").select(""*"");
❌ Avoid using an Edge Function like this:

ts
Copy
Edit
serve(async (req) => {
  const { data, error } = await supabase.from(""leads"").select(""*"");
  return new Response(JSON.stringify(data));
});
➡️ Alternative: Fetch directly from the client if security allows.

✅ Use Row-Level Security (RLS) for Data Access Control
📌 Instead of checking permissions in an Edge Function, use RLS in Supabase.

Bad Example (Using Edge Function for security):
ts
Copy
Edit
serve(async (req) => {
  const apiKey = req.headers.get(""Authorization"");
  if (apiKey !== ""secret"") return new Response(""Unauthorized"", { status: 401 });

  const { data } = await supabase.from(""leads"").select(""*"");
  return new Response(JSON.stringify(data));
});
Better Alternative (Use Supabase RLS Policies):
sql
Copy
Edit
CREATE POLICY ""Users can only access their leads""
ON leads FOR SELECT
USING (auth.uid() = user_id);
➡️ Alternative: RLS ensures data security without writing extra functions.

✅ Use PostgreSQL Functions for Complex Queries
📌 Instead of fetching data and processing it in an Edge Function, use a PostgreSQL function for efficiency.

Bad Example (Using Edge Function for data aggregation):
ts
Copy
Edit
serve(async (req) => {
  const { data } = await supabase.from(""leads"").select(""status"");
  const summary = data.reduce((acc, lead) => {
    acc[lead.status] = (acc[lead.status] || 0) + 1;
    return acc;
  }, {});
  return new Response(JSON.stringify(summary));
});
Better Alternative (Use PostgreSQL Function for aggregation):
sql
Copy
Edit
CREATE FUNCTION count_leads_by_status()
RETURNS TABLE(status TEXT, count BIGINT)
LANGUAGE sql AS
$$
SELECT status, COUNT(*) FROM leads GROUP BY status;
$$;
➡️ Alternative: Call this function via Supabase:

ts
Copy
Edit
const { data } = await supabase.rpc(""count_leads_by_status"");
⚡ Faster & more scalable than an Edge Function!

✅ Use API Routes (Next.js) for Custom Business Logic
📌 If Next.js can handle logic without requiring an Edge Function, prefer API routes.

Use Case: You need a simple API endpoint, but you don’t need Supabase’s Edge Function execution.
💡 Use Next.js API Routes Instead

ts
Copy
Edit
export default async function handler(req, res) {
  if (req.method === ""POST"") {
    const { data, error } = await supabase.from(""leads"").insert(req.body);
    if (error) return res.status(500).json(error);
    res.status(200).json(data);
  }
}
➡️ Alternative: Next.js API routes are easier to debug and better for non-global requests.

3. Decision Framework: Edge Function vs. Alternative
Use this decision tree to determine if you should use Edge Functions:

1️⃣ Do you need external API calls, server-side processing, or third-party integrations?

✅ Yes → Use Edge Functions
❌ No → Proceed to 2️⃣
2️⃣ Is this a simple data fetch that can be done with Supabase queries?

✅ Yes → Use Database Queries
❌ No → Proceed to 3️⃣
3️⃣ Does it involve complex permissions or access control?

✅ Yes → Use Row-Level Security (RLS)
❌ No → Proceed to 4️⃣
4️⃣ Does it involve aggregating or transforming database data?

✅ Yes → Use PostgreSQL Functions
❌ No → Proceed to 5️⃣
5️⃣ Can the logic be handled by Next.js API Routes without Supabase Edge Functions?

✅ Yes → Use Next.js API Routes
❌ No → Use Edge Functions
4. Summary Table
Use Case	Best Solution
Fetching data (public)	Use Supabase client (supabase.from(""table"").select(""*""))
Fetching data (secured)	Use RLS & Supabase policies
Data aggregation	Use PostgreSQL functions (SELECT COUNT(*))
Authentication & role-based access	Use Supabase Auth & RLS
Custom API for external integration	Use Edge Functions
Scheduled background jobs	Use external cron jobs (GitHub Actions, Zapier)
Processing user input before saving	Use Edge Functions
Sending webhooks	Use Edge Functions
Next.js API endpoints (not requiring Supabase edge execution)	Use Next.js API Routes (pages/api/)
Final Thoughts
Use Edge Functions when you need serverless execution, external API calls, security middleware, or background jobs.
Use Supabase RLS & PostgreSQL functions for performance and scalability instead of handling logic in Edge Functions.
Use Next.js API Routes when you need custom APIs that are app-specific.
This ensures performance, scalability, and maintainability while using Edge Functions only where necessary. 🚀"	"Table Name: ai_prompts
Attributes: idapplication_idprompt_textcreated_at, Table Name: ai_instructions
Attributes: idapplication_idinstructionscreated_at, Table Name: ai_usage_cost
Attributes: idapplication_idusage_countcostcreated_at, Table Name: ai_models
Attributes: idapplication_idmodel_nameversionprovidercreated_at, Table Name: ai_agents
Attributes: idapplication_idagent_namerolestatuscreated_at, Table Name: edge_use_cases
Attributes: idapplication_idnamedescriptioncreated_at, Table Name: edge_alternatives
Attributes: idapplication_idalternativereasoncreated_at, Table Name: edge_decision_framework
Attributes: idapplication_idcriteriadecisioncreated_at"
Define Authentication & Authorization Rules	"Since Supabase provides authentication, define how users should register, log in, and access data.

Auth Requirements
Users can sign up with email/password
Users can reset passwords
Roles: Admin, Manager, Sales Rep
RBAC (Role-Based Access Control)
Admin: Full access
Manager: Can manage leads and tasks
Sales Rep: Can only view assigned leads
Example Prompt for Cursor AI
""Implement Supabase authentication with email/password signup and login. Define roles (Admin, Manager, Sales Rep) and set authorization rules:

Admins can manage everything
Managers can modify leads/tasks but not delete users
Sales Reps can only access assigned leads Use Supabase RLS (Row-Level Security) to enforce access controls."""	"Table Name: ai_prompts
Attributes: idapplication_idprompt_textcreated_at, Table Name: ai_instructions
Attributes: idapplication_idinstructionscreated_at, Table Name: ai_usage_cost
Attributes: idapplication_idusage_countcostcreated_at, Table Name: ai_models
Attributes: idapplication_idmodel_nameversionprovidercreated_at, Table Name: ai_agents
Attributes: idapplication_idagent_namerolestatuscreated_at, Table Name: roles
Attributes: idapplication_idnamedescriptioncreated_at, Table Name: permissions
Attributes: idrole_idtable_idactioncreated_at, Table Name: auth_methods
Attributes: idapplication_idmethodstatuscreated_at, Table Name: security
Attributes: idapplication_idrulecreated_at"
Define API Routes and Data Fetching	"Supabase works well with server-side fetching (SSR) and client-side fetching (CSR).

API Routes
/api/leads → Fetch all leads (Admin/Manager only)
/api/leads/[id] → Fetch single lead details (Assigned users only)
/api/tasks → Fetch tasks assigned to the logged-in user
Example Prompt for Cursor AI
""Generate Next.js API routes using Supabase. Define:

/api/leads: Fetch all leads
/api/leads/[id]: Fetch single lead
/api/tasks: Fetch tasks for the logged-in user Use getServerSideProps for initial fetch and useEffect for real-time updates."""	"Table Name: ai_prompts
Attributes: idapplication_idprompt_textcreated_at, Table Name: ai_instructions
Attributes: idapplication_idinstructionscreated_at, Table Name: ai_usage_cost
Attributes: idapplication_idusage_countcostcreated_at, Table Name: ai_models
Attributes: idapplication_idmodel_nameversionprovidercreated_at, Table Name: ai_agents
Attributes: idapplication_idagent_namerolestatuscreated_at, Table Name: api_endpoints
Attributes: idapplication_idroutemethoddescriptioncreated_at, Table Name: data_fetching
Attributes: idapplication_idstrategycreated_at, Table Name: real_time_updates
Attributes: idapplication_idtable_idenabledcreated_at, Table Name: error_handling
Attributes: idapplication_iderror_typeresolutioncreated_at"
Define UI Components	"Specify reusable UI components for efficient development.

Components
LeadCard → Displays lead info
TaskCard → Shows task details
UserAvatar → Shows profile image
Navbar & Sidebar → Navigation
Modal → Forms and popups
Example Prompt for Cursor AI
""Create React components using ShadCN for a Next.js CRM. Components:

LeadCard: Shows lead details
TaskCard: Shows task info
Navbar: Top navigation bar
Sidebar: Sidebar menu
Modal: Used for forms Use Tailwind CSS for styling and ensure accessibility."""	"Table Name: ai_prompts
Attributes: idapplication_idprompt_textcreated_at, Table Name: ai_instructions
Attributes: idapplication_idinstructionscreated_at, Table Name: ai_usage_cost
Attributes: idapplication_idusage_countcostcreated_at, Table Name: ai_models
Attributes: idapplication_idmodel_nameversionprovidercreated_at, Table Name: ai_agents
Attributes: idapplication_idagent_namerolestatuscreated_at, Table Name: ui_components
Attributes: application_idnametypecreated_atid, Table Name: component_props
Attributes: idcomponent_idprop_nameprop_typedefault_valuecreated_at, Table Name: component_styling
Attributes: idcomponent_idcss_classestheme_supportcreated_at"
Define Real Time Features	"Leverage Supabase’s real-time capabilities.

Example Prompt for Cursor AI
""Enable real-time updates for the leads and tasks tables using Supabase subscriptions. Ensure that when a new lead or task is added, it automatically updates on the frontend without needing a manual refresh."""	"Table Name: ai_prompts
Attributes: idapplication_idprompt_textcreated_at, Table Name: ai_instructions
Attributes: idapplication_idinstructionscreated_at, Table Name: ai_usage_cost
Attributes: idapplication_idusage_countcostcreated_at, Table Name: ai_models
Attributes: idapplication_idmodel_nameversionprovidercreated_at, Table Name: ai_agents
Attributes: idapplication_idagent_namerolestatuscreated_at, Table Name: real_time_tables
Attributes: idapplication_idtable_namecreated_at, Table Name: subscriptions
Attributes: idreal_time_table_ideventcallback_urlcreated_at"
Deployment Strategy 	"Define how the app will be deployed.

Example Prompt for Cursor AI
""Deploy the Next.js app on Vercel and connect it to Supabase. Provide CI/CD instructions and environment variables setup:

NEXT_PUBLIC_SUPABASE_URL
NEXT_PUBLIC_SUPABASE_ANON_KEY
SUPABASE_SERVICE_ROLE_KEY Use Vercel environment variables for security."""	"Table Name: ai_prompts
Attributes: idapplication_idprompt_textcreated_at, Table Name: ai_instructions
Attributes: idapplication_idinstructionscreated_at, Table Name: ai_usage_cost
Attributes: idapplication_idusage_countcostcreated_at, Table Name: ai_models
Attributes: idapplication_idmodel_nameversionprovidercreated_at, Table Name: ai_agents
Attributes: idapplication_idagent_namerolestatuscreated_at, Table Name: hosting
Attributes: idapplication_idproviderregionstatuscreated_at, Table Name: env_variables
Attributes: idapplication_idkeyvaluesecurecreated_at, Table Name: ci_cd
Attributes: idapplication_idpipeline_namestatuscreated_at"
Optimization & Performance	"Specify best practices for speed and UX.

Example Prompt for Cursor AI
""Optimize the app by:

Using ISR (Incremental Static Regeneration) for non-sensitive pages
Lazy-loading components where applicable
Implementing pagination for large datasets
Prefetching frequently used data"""	"Table Name: ai_prompts
Attributes: idapplication_idprompt_textcreated_at, Table Name: ai_instructions
Attributes: idapplication_idinstructionscreated_at, Table Name: ai_usage_cost
Attributes: idapplication_idusage_countcostcreated_at, Table Name: ai_models
Attributes: idapplication_idmodel_nameversionprovidercreated_at, Table Name: ai_agents
Attributes: idapplication_idagent_namerolestatuscreated_at, Table Name: isr
Attributes: idapplication_idenabledintervalcreated_at, Table Name: lazy_loading
Attributes: idapplication_idenabledcomponentscreated_at, Table Name: pagination
Attributes: idapplication_idenabledstrategycreated_at"
Testing Plan	"Ensure the app works as expected.

Example Prompt for Cursor AI
""Write Jest & React Testing Library test cases for:

Authentication flow
API calls (fetching leads, tasks)
UI interactions (adding leads, updating tasks) Use Cypress for end-to-end testing."""	"Table Name: ai_prompts
Attributes: idapplication_idprompt_textcreated_at, Table Name: ai_instructions
Attributes: idapplication_idinstructionscreated_at, Table Name: ai_usage_cost
Attributes: idapplication_idusage_countcostcreated_at, Table Name: ai_models
Attributes: idapplication_idmodel_nameversionprovidercreated_at, Table Name: ai_agents
Attributes: idapplication_idagent_namerolestatuscreated_at, Table Name: unit_tests
Attributes: idapplication_idtest_namestatuscreated_at, Table Name: api_tests
Attributes: idapplication_idendpointstatuscreated_at, Table Name: e2e_tests
Attributes: idapplication_idscenariostatuscreated_at, Table Name: auth_tests
Attributes: idapplication_idtest_typestatuscreated_at"

I'll help you troubleshoot the localhost loading issues. However, I notice that you haven't shared the specific error messages you're seeing. Without seeing the actual errors, I'll provide a systematic approach to resolve common Next.js localhost loading issues:
First, try these basic troubleshooting steps:
Apply
Run
Check if your development server is running correctly:
Apply
Run
Common issues and solutions:
Port conflicts:
If port 3000 is already in use, try:
Apply
Run
TypeScript errors:
Run TypeScript checker:
Apply
Run
If you're still having issues, please share:
The exact error messages you're seeing
Your package.json contents
The Next.js version you're using
The contents of your next.config.js file
This will help me provide more specific guidance. Also, consider using agent mode which can look at your actual codebase to identify the specific issues causing the errors.
Would you be able to share the specific error messages you're seeing? This would help me provide more targeted assistance.